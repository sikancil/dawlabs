/**
 * Next-Generation Deployment Intelligence API Server
 * RESTful API exposing multi-oracle intelligence capabilities
 */

import { createServer } from 'http';
import { parse } from 'url';
import { MultiOraclePackageAnalyzer } from '../utils/multi-oracle-analyzer.js';
import { LearningEngine } from '../utils/learning-engine.js';
import { IntelligenceMonitoringSystem } from '../utils/monitoring-system.js';
import { AutomationWorkflows } from '../utils/automation-workflows.js';

/**
 * Enterprise Intelligence API Server
 * Exposes deployment intelligence via REST API
 */
export class IntelligenceAPIServer {
  constructor(port = 3000) {
    this.port = port;
    this.server = null;
    this.analyzer = new MultiOraclePackageAnalyzer();
    this.learningEngine = new LearningEngine();
    this.monitoring = new IntelligenceMonitoringSystem();
    this.workflows = new AutomationWorkflows();

    // CORS headers
    this.corsHeaders = {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    };

    this.setupRoutes();
    this.startMonitoring();
  }

  /**
   * Setup API routes
   */
  setupRoutes() {
    this.routes = new Map();

    // Health check
    this.routes.set('GET /health', this.handleHealthCheck.bind(this));

    // Intelligence analysis endpoints
    this.routes.set('POST /api/v1/analyze', this.handleAnalyzePackage.bind(this));
    this.routes.set('POST /api/v1/analyze/batch', this.handleBatchAnalysis.bind(this));
    this.routes.set(
      'GET /api/v1/analyze/status/:packageName',
      this.handleAnalysisStatus.bind(this),
    );

    // Learning engine endpoints
    this.routes.set('GET /api/v1/learning/analytics', this.handleLearningAnalytics.bind(this));
    this.routes.set('POST /api/v1/learning/outcome', this.handleRecordOutcome.bind(this));
    this.routes.set(
      'GET /api/v1/learning/patterns/:packageName',
      this.handlePackagePatterns.bind(this),
    );

    // Monitoring endpoints
    this.routes.set('GET /api/v1/monitoring/metrics', this.handleGetMetrics.bind(this));
    this.routes.set('GET /api/v1/monitoring/alerts', this.handleGetAlerts.bind(this));
    this.routes.set('GET /api/v1/monitoring/dashboard', this.handleGetDashboard.bind(this));
    this.routes.set(
      'POST /api/v1/monitoring/alerts/:alertId/resolve',
      this.handleResolveAlert.bind(this),
    );

    // Workflow endpoints
    this.routes.set('GET /api/v1/workflows', this.handleListWorkflows.bind(this));
    this.routes.set(
      'POST /api/v1/workflows/:workflowId/execute',
      this.handleExecuteWorkflow.bind(this),
    );
    this.routes.set(
      'GET /api/v1/workflows/execution/:executionId',
      this.handleGetExecutionStatus.bind(this),
    );

    // Oracle endpoints
    this.routes.set('GET /api/v1/oracles/status', this.handleOracleStatus.bind(this));
    this.routes.set('GET /api/v1/oracles/:oracle/metrics', this.handleOracleMetrics.bind(this));

    // System endpoints
    this.routes.set('GET /api/v1/system/info', this.handleSystemInfo.bind(this));
    this.routes.set('GET /api/v1/system/stats', this.handleSystemStats.bind(this));
  }

  /**
   * Start the API server
   */
  start() {
    return new Promise((resolve, reject) => {
      this.server = createServer((req, res) => {
        this.handleRequest(req, res);
      });

      this.server.listen(this.port, () => {
        // eslint-disable-next-line no-console
  console.log(`ðŸŒ Intelligence API Server running on port ${this.port}`);
        // eslint-disable-next-line no-console
  console.log(`ðŸ“š API Documentation: http://localhost:${this.port}/api/v1/docs`);
        resolve(this.server);
      });

      this.server.on('error', reject);
    });
  }

  /**
   * Handle HTTP requests
   */
  async handleRequest(req, res) {
    try {
      // Set CORS headers
      Object.entries(this.corsHeaders).forEach(([key, value]) => {
        res.setHeader(key, value);
      });

      // Handle OPTIONS requests for CORS
      if (req.method === 'OPTIONS') {
        res.writeHead(200);
        res.end();
        return;
      }

      const url = parse(req.url, true);
      const method = req.method.toUpperCase();
      const path = url.pathname;

      // Find matching route
      for (const [routeKey, handler] of this.routes.entries()) {
        const [routeMethod, routePath] = routeKey.split(' ');
        const routeRegex = new RegExp('^' + routePath.replace(/:[^/]+/g, '([^/]+)') + '$');
        const match = path.match(routeRegex);

        if (match && method === routeMethod) {
          const params = match.slice(1);
          const query = url.query;
          const body = await this.parseRequestBody(req);

          try {
            const result = await handler(req, res, params, query, body);
            if (!res.headersSent) {
              this.sendJSON(res, result, 200);
            }
          } catch (error) {
            console.error('API Error:', error);
            if (!res.headersSent) {
              this.sendJSON(
                res,
                {
                  error: 'Internal Server Error',
                  message: error.message,
                  stack: process.env.NODE_ENV === 'development' ? error.stack : undefined,
                },
                500,
              );
            }
          }
          return;
        }
      }

      // 404 - Route not found
      if (!res.headersSent) {
        this.sendJSON(
          res,
          {
            error: 'Not Found',
            message: `Route ${method} ${path} not found`,
            availableRoutes: Array.from(this.routes.keys()),
          },
          404,
        );
      }
    } catch (error) {
      console.error('Request handling error:', error);
      if (!res.headersSent) {
        this.sendJSON(
          res,
          {
            error: 'Internal Server Error',
            message: error.message,
          },
          500,
        );
      }
    }
  }

  /**
   * Route handlers
   */
  async handleHealthCheck(_req, _res) {
    return {
      status: 'healthy',
      timestamp: new Date().toISOString(),
      version: '1.0.0',
      uptime: process.uptime(),
      memory: process.memoryUsage(),
      monitoring: {
        active: this.monitoring.isMonitoring,
        activeAlerts: this.monitoring.getActiveAlerts().length,
      },
    };
  }

  async handleAnalyzePackage(_req, _res, _params, _query, body) {
    const { packageName, version, packagePath } = body;

    if (!packageName || !version) {
      throw new Error('packageName and version are required');
    }

    // eslint-disable-next-line no-console
  console.log(`ðŸ“Š API Request: Analyzing ${packageName}@${version}`);

    const analysis = await this.analyzer.analyzeWithIntelligence(packageName, version, packagePath);

    // Record analysis for monitoring
    this.monitoring.recordAnalysis(analysis, 'pending', {
      source: 'api',
      requestId: this.generateRequestId(),
    });

    return {
      success: true,
      analysis,
      requestId: this.generateRequestId(),
      timestamp: new Date().toISOString(),
    };
  }

  async handleBatchAnalysis(_req, _res, _params, _query, body) {
    const { packages } = body;

    if (!Array.isArray(packages) || packages.length === 0) {
      throw new Error('packages array is required');
    }

    if (packages.length > 10) {
      throw new Error('Maximum 10 packages per batch analysis');
    }

    // eslint-disable-next-line no-console
  console.log(`ðŸ“Š API Request: Batch analyzing ${packages.length} packages`);

    const startTime = Date.now();
    const results = [];

    for (const pkg of packages) {
      try {
        const analysis = await this.analyzer.analyzeWithIntelligence(
          pkg.packageName,
          pkg.version,
          pkg.packagePath,
        );

        results.push({
          package: pkg,
          success: true,
          analysis,
        });
      } catch (error) {
        results.push({
          package: pkg,
          success: false,
          error: error.message,
        });
      }
    }

    const totalTime = Date.now() - startTime;

    return {
      success: true,
      results,
      summary: {
        totalPackages: packages.length,
        successful: results.filter(r => r.success).length,
        failed: results.filter(r => !r.success).length,
        totalTime,
        averageTimePerPackage: totalTime / packages.length,
      },
      requestId: this.generateRequestId(),
      timestamp: new Date().toISOString(),
    };
  }

  async handleGetMetrics(_req, _res, _params, _query) {
    const dashboard = this.monitoring.getDashboardData();
    return {
      ...dashboard,
      requestId: this.generateRequestId(),
    };
  }

  async handleGetAlerts(_req, _res, _params, query) {
    const { status, severity, limit = 50 } = query;
    let alerts = this.monitoring.getActiveAlerts();

    if (status) {
      alerts = alerts.filter(a => a.status === status);
    }

    if (severity) {
      alerts = alerts.filter(a => a.severity === severity);
    }

    return {
      alerts: alerts.slice(0, parseInt(limit)),
      count: alerts.length,
      requestId: this.generateRequestId(),
      timestamp: new Date().toISOString(),
    };
  }

  async handleGetDashboard(_req, _res, _params, _query) {
    const dashboard = this.monitoring.getDashboardData();

    // Add workflow status
    const workflowStatus = this.workflows.getWorkflowStatus();
    dashboard.workflows = workflowStatus;

    // Add system info
    dashboard.system = await this.getSystemInfo();

    return {
      ...dashboard,
      requestId: this.generateRequestId(),
      timestamp: new Date().toISOString(),
    };
  }

  async handleListWorkflows(_req, _res, _params, _query) {
    const workflows = Array.from(this.workflows.workflows.entries()).map(([id, workflow]) => ({
      id,
      ...workflow,
    }));

    return {
      workflows,
      count: workflows.length,
      requestId: this.generateRequestId(),
      timestamp: new Date().toISOString(),
    };
  }

  async handleExecuteWorkflow(_req, _res, params, _query, body) {
    const { packages, options = {} } = body;
    const workflowId = params.workflowId;

    // eslint-disable-next-line no-console
  console.log(
      `ðŸš€ API Request: Executing workflow ${workflowId} with ${packages.length} packages`,
    );

    const execution = await this.workflows.executeWorkflow(workflowId, packages, options);

    return {
      success: true,
      executionId: execution.id,
      workflowId,
      status: execution.status,
      packages,
      options,
      requestId: this.generateRequestId(),
      timestamp: new Date().toISOString(),
    };
  }

  async handleGetExecutionStatus(_req, _res, params) {
    const executionId = params.executionId;
    // In a real implementation, you would track execution state
    // For demonstration, we'll return a simulated status

    return {
      executionId,
      status: 'completed',
      progress: 100,
      startTime: Date.now() - 30000,
      duration: 30000,
      requestId: this.generateRequestId(),
      timestamp: new Date().toISOString(),
    };
  }

  async handleLearningAnalytics(_req, _res) {
    const analytics = this.learningEngine.getAnalytics();
    return {
      ...analytics,
      requestId: this.generateRequestId(),
      timestamp: new Date().toISOString(),
    };
  }

  async handleRecordOutcome(_req, _res, _params, _query, body) {
    const { analysis, outcome, details } = body;

    const record = await this.learningEngine.recordOutcome(analysis, outcome, details);

    return {
      success: true,
      record,
      requestId: this.generateRequestId(),
      timestamp: new Date().toISOString(),
    };
  }

  async handleSystemInfo(_req, _res) {
    return await this.getSystemInfo();
  }

  async handleSystemStats(_req, _res) {
    const metrics = this.monitoring.getDashboardData();
    const analytics = this.learningEngine.getAnalytics();

    return {
      deployment: {
        totalAnalyses: analytics.totalDeployments,
        successRate: analytics.overallSuccessRate,
        predictionAccuracy: analytics.predictionAccuracy,
        learningProgress: analytics.learningProgress,
      },
      performance: {
        averageResponseTime: metrics.recentPerformance.averageResponseTime,
        throughput: metrics.recentPerformance.count,
        uptime: metrics.uptime,
      },
      intelligence: {
        oracleCount: 6,
        activeOracles: metrics.oracleHealth.size,
        averageConfidence: metrics.recentPerformance.averageConfidence,
      },
      requestId: this.generateRequestId(),
      timestamp: new Date().toISOString(),
    };
  }

  /**
   * Additional route handlers
   */
  async handleAnalysisStatus(req, res, params) {
    const packageName = params[0];
    return {
      packageName,
      status: 'completed',
      lastAnalyzed: Date.now() - 60000,
      requestId: this.generateRequestId(),
      timestamp: new Date().toISOString(),
    };
  }

  async handlePackagePatterns(req, res, params) {
    const packageName = params[0];
    return {
      packageName,
      patterns: [],
      confidence: 0.8,
      requestId: this.generateRequestId(),
      timestamp: new Date().toISOString(),
    };
  }

  async handleResolveAlert(req, res, params, query, body) {
    const alertId = params[0];
    const { resolution } = body;

    return {
      success: true,
      alertId,
      resolved: true,
      resolution,
      requestId: this.generateRequestId(),
      timestamp: new Date().toISOString(),
    };
  }

  async handleOracleStatus(_req, _res) {
    return {
      oracles: [
        { name: 'NpmRegistryOracle', status: 'healthy', responseTime: 120 },
        { name: 'GitHistoryOracle', status: 'healthy', responseTime: 200 },
        { name: 'BuildArtifactOracle', status: 'healthy', responseTime: 150 },
        { name: 'LocalStateOracle', status: 'healthy', responseTime: 50 },
        { name: 'NetworkCacheOracle', status: 'healthy', responseTime: 80 },
        { name: 'SemanticVersionOracle', status: 'healthy', responseTime: 100 },
      ],
      totalOracles: 6,
      healthyOracles: 6,
      requestId: this.generateRequestId(),
      timestamp: new Date().toISOString(),
    };
  }

  async handleOracleMetrics(req, res, params) {
    const oracle = params[0];
    return {
      oracle,
      metrics: {
        totalRequests: 100,
        successRate: 0.95,
        averageResponseTime: 120,
        lastRequest: Date.now() - 1000,
      },
      requestId: this.generateRequestId(),
      timestamp: new Date().toISOString(),
    };
  }

  async parseRequestBody(req) {
    return new Promise(resolve => {
      let body = '';
      req.on('data', chunk => {
        body += chunk.toString();
      });
      req.on('end', () => {
        try {
          resolve(body ? JSON.parse(body) : {});
        } catch {
          resolve({});
        }
      });
    });
  }

  sendJSON(res, data, statusCode = 200) {
    const jsonData = JSON.stringify(data, null, 2);
    res.writeHead(statusCode, {
      'Content-Type': 'application/json',
      'Content-Length': Buffer.byteLength(jsonData),
    });
    res.end(jsonData);
  }

  generateRequestId() {
    return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  async getSystemInfo() {
    return {
      name: 'Deployment Intelligence API',
      version: '1.0.0',
      description: 'Next-Generation Multi-Oracle Deployment Intelligence',
      uptime: process.uptime(),
      memory: process.memoryUsage(),
      nodeVersion: process.version,
      platform: process.platform,
      arch: process.arch,
      environment: process.env.NODE_ENV || 'development',
      timestamp: new Date().toISOString(),
    };
  }

  startMonitoring() {
    this.monitoring.startMonitoring(15000); // Monitor every 15 seconds
  }

  /**
   * Stop the API server
   */
  stop() {
    return new Promise(resolve => {
      if (this.server) {
        this.monitoring.stopMonitoring();
        this.server.close(() => {
          // eslint-disable-next-line no-console
  console.log('ðŸŒ Intelligence API Server stopped');
          resolve();
        });
      } else {
        resolve();
      }
    });
  }
}

// Start server if this file is run directly
if (import.meta.url === `file://${process.argv[1]}`) {
  const server = new IntelligenceAPIServer(3000);

  server.start().catch(error => {
    console.error('Failed to start API server:', error);
    process.exit(1);
  });
}
